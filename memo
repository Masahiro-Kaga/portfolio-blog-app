先に各ページを作成＋メタデータ設定してから始めたほうが良いと思われる。


Logo,icon作成
    https://hatchful.shopify.com/ja/
avatar作成
    https://charat.me/face/create/

index.jsの以下を削除。多分本番だと必要。

import Head from "next/head";

      <Head>
        <title>Portfolio of Masahiro Kaga</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

!!!!!!!!!
必要は必要だけど、htmlはnextにはない。_document.jsを作る。マックスの最後のセクションに出てくる。
そこでヘッダとかを改めて設定する。https://nextjs.org/docs/basic-features/font-optimization
Googlefontの追加方法も上のURL参照。

さて
必要コンポーネント作成
    ただし、slugとかcontactとかはまだいらない、逆にこんがらがる。必要なhero.jsとかページ頭のindex.jsとかだけでいい。

css
    varを使って、各cssで変数呼び出ししてる。

写真はpublicの中にimagesフォルダを作って入れること。
写真のsrc指定はちょっと特殊。
    publicフォルダは、ルートにあるという設定に自動で置き換わっているため、パスは/imageから始めていい。
また、写真は実際の画像の大きさにできるだけ近づける必要があり、その後はいくらでもnext機能でなんとでもなると。なぜなら、小さい設定にすると、それを今度cssで大きくしても画像が荒くなり、また大きくすると調整が難しくデータを食うから。



Hero コンポーネント、CSS完成して、index.jsで表示。

Nextに標準で入ってるImageコンポーネント、これを使ったほうがいいみたい。説明わかりにくい、でもレイジーローディングとか標準になってて。URLわかりやすい、使い方もあり。
https://maku.blog/p/fw7gpx7/

あとは、emotion使う時の注意事項。それまで全然効かなかった。
/** @jsxImportSource @emotion/react */をプラグマっつーらしい。
https://webfun-style.com/react-css/#:~:text=%E3%81%A6%E4%BE%BF%E5%88%A9%E3%81%A7%E3%81%99%E3%80%82-,Emotion,-%E3%81%BE%E3%81%9A%E3%81%AF%E3%80%81%E4%BB%A5%E4%B8%8B%E3%81%AE

ーーーーーーーーーーーーーーーーーーーー

次にナビゲーションバー。

1 layoutjsを作る、そして_app.jsをlayout.jsで囲む、目的は、全てのページにナビゲーションバーをつけるため。
2 mainnavigationjsを作る。Link忘れずに。まずはコンタクトとポストのみ。

ちなみに、アンカータグは絶対に必要！以下、めちゃくちゃわかりやすい理由。
https://zenn.dev/luvmini511/articles/b5e9f02cadd160

3 Logoをインポートして入れる。アンカータグ、これ、いるらしい。Logoのリンク先はルートつまりホームになるようにする。

CSS難しそうだなー、でも頑張ろう


ーーーーーーーーーーーーーーーーーーーー


次にfeaturedpostjsと思いきや、その中に入るpostのグリッドです。

この部分は、ルートのページにPostしたブログの一部を写真下にレンダリングして、メインは全てのポストをAllPostというコンポーネント

page index.js - featuredpost/all-posts
 - postgrid - postitem
とりあえずこの流れでちゃんと繋がってデータ行き来してるか確認。

最終的には、featuredpostで最新のポストだけを表示して、all-postsで全部のポストを表示する的なこと。今回はどっちでも全部表示する。

postっていうフォルダをコンポーネント直下に作る。あと２つ（gridとitem）のcssとjsのコンポーネント作る。
＊＊＊＊＊postitemでどんな変数を上から持ってきて表示するか、あらかじめ想定してpropsをバラしておく。

defrastructureの理解が少し難解。

function PostsGrid(props) {
  const { posts } = props;
propsの下にpostsっつーオブジェクト名のものがあって、その名前そのまま使ってpostsを存在させてる。
propsそのまま下で同じ名前でつかうんだろうから、いつでもこんな感じで定数に入れて使ってもいいかもね。

function PostItem(props) {
  const { title, image, excerpt, date, slug } = props.post;
props.postの下にそれぞれの名前のキーがあって、その名前そのまま使ってこのコンポーネントでも使ってるってこと。

post-item.jsにて、
  const imagePath = `/images/posts/${slug}/${image}`;
としてるが、slugとimageの部分、どう設定されるのかよくわかりません。
とにかくITEMがコードおおくなる。でもいろんな技が盛りだくさん。

ダミーデータを使ってテスト。ダミーデータがちゃんとグリッドコンポーネントで活きるかどうか。だからダミーテスト必要。

postitemコンポーネントのLINKにhrefを設定する。
これが実際に、slugページと関連してくるらしい。が、まだ意味がわからない。

183の10:40くらい、imageの画像をピタッとボックスにフィットさせる方法、layout=absoluteとしている。nextのImageを使ってる。

最後にall-postsコンポーネントとpostsのインデックスページ。ここがfeaturedポストよりもメインのはず。
ダミーデータをポストのインデックスjsにコピーして使う。

とりま184まで
page index.js - featuredpost - postgrid - postitem

ーーーーーーーーーーーーーーーーーーーー

今度は、ポストの中のカードをクリックしたら飛ぶ先の記事部分をマークアップで作成。

コンポーネント作成
postsフォルダ
|
--- post-detailフォルダ
    |
    ---post-content.js
        |
        ---post-header.js
そしてそれをページ、post/[slug].jsに載せる、という構造。

とりあえず完成版見てみてよ、それから。

contentにダミーデータ置く、イメージパス設定、その二つをしたのpostheaderに渡す。

185終わり
186 added react-markdown

マークダウンというものを使う。

ブログであれば、これが使いやすいかも。使い方もあり。
https://hikopro.com/notion-manual/

マークアップは、htmlの中でタグとか使って書いたら、それがブラウザにシンプルに表示される、色とか大きさを変えて。でもマークダウンは逆で、WordPressみたいに色々書いて文字色変えたりして、それをネットにアップしたらhtml形式に自動で変わってるみたいなこと。#をつけるとh１とかになる、みたいな。対応表はどっかにある。
したのリンクはわかりやすい説明とか。

https://zenn.dev/rinka/articles/b260e200cb5258

まずnpm install react-markdown
そして、マークダウン表現使ってるpost-contentコンポに搭載する。
マークダウンで表現されている文章を保存するファイルの拡張子は、.md。ReadMe.mdが実際にそうよね。

マークダウンファイルの中に、変数とか配列？的なものを入れておくことができる。Yalmという記法によって。JSONに変換できるものだが、記法に少し癖があるらしい。
mdファイルの中なら、
---
(Yaml表現)
---
という感じで---に囲まれる必要ある。

https://tracpath.com/works/development/yaml_beginers_guide/

https://qiita.com/endk/items/2ae6ab257f0ad42a3bd8

んでその下にマークダウン書いていくっていう感じ。
187の6:20あたり。
ということで、
postsコンポーネント直下に、mdファイルを作って必要なデータとマークダウンコンテントを入力してく。

以上187まで

----------------------------------------

188はちょっと濃い
から、コード上から順に潰していく。
結論から言うと、３つのファンクションは全て返り値が以下のオブジェクトになり、２と３を外部にエクスポートするという作業。
    １ slug名＋mdファイルのデータのセット
    ２ 上の１を使って、格納されてるslug名＋mdデータを配列へ入れる
    ３ 上の２のうち、featureに載せるものだけ抽出した配列を作る
        結果、ダミーデータと同じもの（配列とオブジェクト、それぞれの変数）がゲットできる。

事前の留意事項として、このフォルダのなかで、console.logしようとしても、サーバーサイドで実行するという扱いになるらしいので、クライアントサイドではこのconsole.logは表示されない。サーバーサイドのほうでよろしくやってるっぽい。

先にこれを読んでおいたら、SSG/SSRの違いとか同時に使えるとかがわかってよいかも。
https://zenn.dev/luvmini511/articles/1523113e0dec58
また、大事なこととして、getStaticPropsは、コンポーネントではなくて、pageに直接使われることに注目。おそらく、事前レンダリングとかそれに伴うSEOとかは、当然大元のページに直接関連するからだと思う。


関連フォルダとして、
lib
|
--posts.util.js 作成
Libフォルダの意味はこちら。
https://qiita.com/kentt/items/c86782b481ec175a57e2
一方別のサイトでは、
	Firebaseなどの外部のライブラリに関する処理はここに配置する。
と記載されている。とにかくデータの変化がない、かつそのアプリに個別に存在する設定ファイルなどはこちらということ。

fsとかpathって？-> サーバーサイド（node.js）のモジュールらしい。サーバーサイドのものだけど、ここで使ってもいいの？に対する質問はurl参照。
https://www.wakuwakubank.com/posts/466-javascript-module-import-export/
https://zenn.dev/kensukem18/scraps/205e579545b335

fs
 https://qiita.com/tarotaro1129/items/135ef8d8ce4c1c08c9bb
 FILE SYSTEMの略か。

path
 色んなpathのパーツを引き出せる。
 path.dirname('./dir/test.txt') だと、test が返ってくる。
 https://qiita.com/oblivion/items/e9677ef4ca38643aaa14

Gray-matter
 マークダウンがyamlという形式で書かれている場合、このgray-matter使うことで、data（---で囲まれてるところで設定してる変数オブジェクト）とcontent（ｰｰｰより下）の部分を別々に引き出してこれる。
URLの最初の図（左から右）を見て、どうパースされてるか。
https://blog.narumium.net/2020/10/07/next-js%EF%BC%8Bgray-matter%E3%81%AE%E3%82%B9%E3%82%B9%E3%83%A1/
const { data, content } = matter(fileContent);
ってマックスコードあるけど、mdデータ内がdataとcontent部分に分かれてて、それぞれを同じ名前の変数として引き出してるっつーことになる。

process.cwd()ってなんや？
こちらえらいわかりやすい。
https://www.yuuuki-blog.com/2020/10/22/%E3%80%90Node-js%E3%80%91%E3%82%AB%E3%83%AC%E3%83%B3%E3%83%88%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E3%83%BB%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E3%83%91%E3%82%B9%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/

ちなみにprocessはjsで用意されているオブジェクトではない、jsファイルで確認済み。console.logしてみると、cwdの他にargv、chdirなどのファンクションが使えるようになっている。

function getPostsDirectoryの設定
↓
	引数fileNameは、持ってこようとしているマークダウンファイルmdのファイル名文字列。
    filePath:
    process.cwdを使ったら、jsを実行したファイルがあるディレクトリの絶対パスを表示すると説明があるが、
    https://mebee.info/2020/12/01/post-24350/
    どのコンポーネントとかページでも / としかコンソールログで表示されない。これは、マックスいわく、プロジェクト全体の現在のディレクトリ、という意味で値を返すらしい、なので / なんだって。
    とにかく、joinで、 /posts という変数を用意するっつーこと。

    fileContent:
	パスとutf-8を引数に設定して、fsでファイルを読み込む。

	gray-matterで（matter）、読み込んだファイルmdの中からdata部分とcontent部分を抜き出す。matter(fileContent)で、dataとcontentを含んだ一つのオブジェクトが返る。

	mdファイル名のmd拡張子を削除した文字列を変数に入れる。
	これはのちにpost/slugのslug名と同じになるようにする。

	postdataに、slug名、dataをdestructureしたもの、contentのそれぞれのオブジェクトを入れる。

    const postData = {
        slug: postSlug,
        ...data,
        content,
    };
        ↓↓↓↓↓↓↓
    slug:postSlug,

	title: 'Getting Started with NextJS',
    date: '2022-10-15',
    image: getting-started-nextjs.png,
    excerpt: NextJS is a the React framework for production - it makes building fullstack React apps and sites a breeze and ships with built-in SSR.,
    isFeatured: true,
        
    content:"# This is a titlec
        This is some regular text with a [link](https://google.com)"

[それぞれのファンクションの役割]

* function getPostData(ファイル名、拡張子無し)
    ファイルの中身をオブジェクト形式でreturn/抽出する。

* function getPostsFiles()
    ディレクトリの中にある全てのファイル名（拡張子含め）を配列形式で抽出する。

* function getAllPosts()↓
    postFiles:fsのディレクトリ読み込みを使ってmd入ってるフォルダの名前が入った配列を作る。

    allPosts:上で作ったファンクションとmapを使って、ひとつづつ変数に配列形式で入れていく。

    sortedPosts:日付順に並べる。

* getFeaturedPosts()↓
    ここで、各mdのデータ部分でisFeatured:trueになってるものだけフィルターで抽出。

    allPosts:一旦、上の全データ取得。
    eaturedPosts:filterで各mdのisFeatured:trueになってるものだけフィルターで抽出。


----------------------------------------

まだ188だが、ちがうファイルいじる。

pages/index.js
pages/posts/index.js
二つに、上で作ったデータを渡すという流れ。

まず、上で作ったやつのファンクションをインポートして、変数に代入。
その後、reduxとかでもhookでもなく、getStaticProps()というものを使用する。
マックスは、getServerSidePropsも選択肢に入れるべきと言ってたが、
これは、上で作ったデータをpropsと見立てて、propsをファイル内の必要なところに渡す、エクスポートして。
なんでgetServerとかuseEffectを使わなかったのかというのは、0:20くらいから話してる。APIを使ってないkからっていう理由と、SEO的にもこれのほうがいいって。あとは言ってることよくわからん。あと2:50にgetserver使わない理由として、それ使うと
＊＊＊このページに到達したとき全部のページ。コンポーネントを通過する
から遅くなると。
＊＊＊この投稿は毎秒変更されるわけではないから。
もしそういうものならgetserveが良いらしい。

＊＊＊＊＊ちなみに、4:00 getstaticでもrevalidate:（時間）っていうものを付け加えれば、propsを更新するという機能も搭載できるらしい。

----------------------------------------

lib/posts-util.jsの中身を少し形変えた。
export function getPostsFiles() {
  return fs.readdirSync(postsDirectory);
}
を追加して、これを[slug].jsで使えるようにした、必要だから。

[slug].jsのページにpost-content.jsコンポーネントが入ってて、それがURLに入力されたSlug部分に該当するページが表示される内容になってる、かつダミーデータ使ってるので、ダミー消して、slug.jsからpropsでデータ持ってくるようにした。

slug.jsの中で、getPostDataでpost-content.jsコンポーネントに渡すデータを作る。
getStaticPropsとgetStaticPathsという２つのファンクションを作っている。

getStaticProps:

**************************
getServerSidePropsとかgetStaticPropsとかのファンクションは、サーバーサイドで実行してるからコンソールログしてもクライアントサイドでは表示されない。ただし、ターミナルでコンソールログが表示される。getStaticPropsならば、全コードが最初にビルドされた時に表示される（ページを手動で更新するとか）、getServerSidePropなら該当ページに飛んだ際に表示される。

https://reffect.co.jp/react/next-js#:~:text=console.log(context)%E3%81%A7%E7%A2%BA%E8%AA%8D%E3%81%97%E3%81%A6
**************************

[slug].js:
    export function getStaticProps(context) {
        const { params } = context;
        const { slug } = params;
    contextがオブジェクトを返す。そこから分解してURLをゲット。

getStaticPaths: パスを表示するためのものらしい。
    getStaticPropsにはこれが必要、なければエラーが出るとかURLに書いてある。
    https://reffect.co.jp/react/next-js#:~:text=%E3%82%A8%E3%83%A9%E3%83%BC%EF%BC%9AgetStaticPaths%E3%81%8C%E5%BF%85%E8%A6%81
    getStaticPropsでparamsを必要としているが、それをここで取得して、contextに入れる、みたいな。
    実際に、このPathファンクションなしで、getStaticPropsの中で{params}をコンソールログ（結局ターミナル）に表示してもundefinedで返ってくる。
    getStaticPathsによって、pathsとfallbackの二つをリターンする。fallbackの説明も上記URL。

-------------------------------------------------

191
    結論：あまり深入りしなくても良い。GithubのReactmarkdownのページに、詳しく写真を載せる方法などは書いてない。
    ただし、他にmarkdownのコンテンツの中に何かレンダーしたい機能（今回のようにimageだけじゃなくてHighlightingとか）とかあれば、とりあえず、この方法は覚えておく、くらい。
    ちなみに、image.altとimage.properties.srcのimageオブジェクトは、markdownのコンテントの中
    ![Create routes via your file + folder structure](nextjs-file-based-routing.png)
    から来てる。[]内がalt,()内がproperties.src.
    

    マークダウンの記法に変更があるとのワーニング記事。次のセクション行く前にチェック必要。

192 Again,修正版を見てね。

    マークダウンの中に写真入れる的な。
    通常通り入れてしまうと、初ロードされた時にCSSが効かない状態になるため。マイクが最初にその失敗例示してくれてます。

const imagePath = `/images/posts/${post.slug}/${post.image}`;
これは別のやつだからね。これは別に動いてる今回のと関係ない。

いくぜ！
const customRenderers:
    こちら、p(paragraph)とcode(code)のファンクション入ってる。
    どこで実行されるんねん、と。これはcustomRenderersが<ReactMarkDown>のプロパティ、components={***}の中に入れれば、読み込まれたときに実行される、つーか反応するっぽい。

    nodeとかっていう言葉使ってるから、多分、htmlのタグとかになったあとに、該当するノードとかタグみつけて、それをどうにかするっていう処理だと思う。node.children[0]って、多分ルートのすぐしたの全部のタグ？<body>とかの下？を指定してるんだと思う。マックスは、img見つけたら、returnの後のhtmlコードで、上書きする働きって言ってる。


193
    次は、マークダウンの中にコードをみんなにみせたいという設定する。
    react-syntax-highliterというものをnpmインストール。そうしないと、ただ文字列だけ表示されちゃう。Prism以外にも色々あるよ、って。調べてみそ。
    他はコード参照。

-------------------------------------------------

194
    コンタクトページいきましょう。
    コピペ。


195；まずはリクエスト部分のみ。
    apiルータを作ると。リクエストが届いた時の処理を書く。
    handler.jsは、クライアントサイドではなくサーバーサイドで実行されるってさ。
    バリデーションでユーザがアホだったら、該当するstatusにデータ（メッセージ）を送る、json形式に変換してから。
    コピペ。
    ただ、最後のmessageが二つあるのはなぜか。4:10くらいに説明あるけど、意味不明。第１と第２引数で送りたいほうを送る、みたいに言ってるけどどうやって決めんの。

196
    コンタクトフォーム。これもいままでやってるからコード見て。
    bodyを設定する時、2way bindingのためにuseRefも使えるって言ってる。1:55。
    headersも重要らしい、バックエンドで正しくjsonファイルだということを認識させる目的で。
    ここでデバッグのために大事なこと！
    
    先ほど、apiのcontact.jsでコンソール入れた。そしてこれはサーバサイドで実行されるので、コンソールはターミナルに出てくる。ちゃんとデータがいってるか確認すること。

197；次はresponse、とMongoDB
    nextjs/react.js用のMongoDBモジュールをインストールしましょう。
    npm install mongodb

    登録方法は155,156にある。networkのIPaddressに関しては156の3:40。
    Zuittの授業と変わってるところは、IPアドレスを追加してactiveにしたことと、コネクトボタン押してアプリケーションと接続的な部分を引用したこと。

    client定数、まずMongoDBサーバにネット接続、クラウドデータベースにコネクションする。MongoClient.connect()。
    次に db = client.db()では、特定のデータベースとリンクさせる。引数にデータベースの名前入れたらそれとリンクするらしい。

    db.collection("something")は、コレクションの名前を指定。まだコレクションが存在しない場合は作ってくれるらしい。

    const result = await db.collection('messages').insertOne(newMessage);
    このコマンドは、データも挿入するし、resultに挿入成功したデータも入る。

    newMessage.id に、自動でMongoDBでつくられるIDを追加。

-------------------------------------------------

198
    フォームが送信されたときの、フッターあたりにsuccess/errorをだす機能の実装。

    return () => clearTimeout(timer)
    特殊な使い方。これだと、setTimeoutが効かずにすぐクリアされてしまうと思いがちだが、3000秒たった後にclearTimeoutが効果を発揮するらしい。
    マックスは説明していないけど、こういう挙動をするということは覚えておいたほうが良い。

async function sendContactData(contactDetails)
    フェッチしてポストするファンクション。
    フォームが送信された時に発動するように、下のsendMessageHandler内で使われる。

たくさんのuseState

useEffect
    ユーザがデータ送った時にステータスがerror/successになる、それが発火させるもと。
    ３秒後に表示を消す。フェッチによるステータスの初期化。

async function sendMessageHandler(event)
    フォーム送信したときのファンクション。
    メインは上のフェッチファンクション発動。その他、処理後のstateの初期化、if関数でメッセージを表示させるやつの設定とか。


199
    単純にメタデータを追加、各htmlのファイルに、SEO。
    他にも通常Headタグの中にいれられるメタデータは普通に色々入れられる。
    _document.jsと<NextScript>とは、このあとのポータルっていうものを挿入するのに必要になるらしい。

200-以降
    ポータルの機能を入れたり、MongoDBに使うユーザー名とかを環境変数化するとかっていうやつ。見ればわかる。あと、マークダウンの記法のjsとかcssとかの言語ごとにハイライトをしっかりしてくれるやつのインストールとか。
    
    